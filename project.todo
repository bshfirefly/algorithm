第一阶段:
  🎯最终交付成果:
    一个干净的代码库:
      ✔ 插入排序 @done(25-11-07 00:25)
      ✔ 归并排序 @done(25-11-07 11:44)
      ✔ 栈、队列、链表、二叉树和遍历 @done(25-11-07 15:58)
      ✔ 快速排序 @done(25-11-06 21:06)
      ✔ 冒泡排序 @done(25-11-06 20:25)
      ✔ 选择排序 @done(25-11-06 20:25)
      ✔ 关于快排,归并排序的自我理解blog @done(25-11-07 13:13)
  📚概念与理解 (Concepts & Understanding):
    数据结构基础:
        ✔ 什么是连续的内存空间？ @done(25-11-06 10:42)
        ✔ 什么是指针（引用）？什么是节点 (Node)? @done(25-11-06 10:42)
    树形结构:
      树 (Tree) 的核心概念:
        ✔ 弄清楚：节点 (Node)、根 (Root)、叶 (Leaf) @done(25-11-06 10:42)
        ✔ 弄清楚：父 (Parent)、子 (Child) @done(25-11-06 10:42)
        ✔ 弄清楚：深度 (Depth)、高度 (Height) @done(25-11-06 10:46)
  💻编码实现任务 (Coding Implementation Tasks):
    排序算法 (Sorting Algorithms):
      冒泡排序 (Bubble Sort):
        ✔ 复习 @done(25-11-06 11:06)
        ✔ 交付 @done(25-11-06 11:06)
      选择排序 (Selection Sort):
        ✔ 复习 @done(25-11-06 20:21)
        ✔ 交付 @done(25-11-06 20:25)
      快速排序 (Quick Sort):
        ✔ 复习 @done(25-11-06 20:51)
        ✔ 交付 @done(25-11-06 20:51)
      插入排序 (Insertion Sort):
        ✔ 复习 @done(25-11-07 11:17)
        ✔ 交付 @done(25-11-07 00:25)
      归并排序 (Merge Sort):
        ✔ 复习 @done(25-11-07 13:13)
        ✔ 交付 @done(25-11-07 11:44)
    基础数据结构 (Basic Data Structures):
    基于数组 (Array-based):
      ✔ 实现一个基本的栈 (Stack)：利用数组的 push 和 pop (LIFO)。 @done(25-11-06 20:38)
      ✔ 实现一个基本的队列 (Queue)：利用数组的 push 和 shift (FIFO)。 @done(25-11-06 20:41)
    链表 (Linked List):
      ✔ 创建一个 Node 类。 @done(25-11-06 20:53)
      ✔ 创建一个 LinkedList 类，至少包含 append (添加) 和 find (查找) 方法。 @done(25-11-06 21:05)
    高级结构：树 (Advanced Structures: Trees):
      二叉树 (Binary Tree):
        ✔ 实现：创建一个 TreeNode 类(包含 value, left, right)。 @done(25-11-07 13:24)
        ✔ 构建：手动构建一棵简单的二叉树。 @done(25-11-07 13:32)
      树的遍历 (Traversals):
        深度优先遍历 (DFS):
          ✔ 实现：前序遍历 (Pre-order) @done(25-11-07 13:46)
          ✔ 实现：中序遍历 (In-order) @done(25-11-07 13:46)
          ✔ 实现：后序遍历 (Post-order) @done(25-11-07 13:46)
        广度优先遍历 (BFS):
          ✔ 实现：使用你在 B 部分中实现的队列 (Queue) 来完成。 @done(25-11-07 15:58)
第二阶段:
    🎯最终交付成果:
        第二阶段目标:
            ☐ 熟练掌握二叉搜索树(BST)和哈希表的 CRUD 操作及其效率分析。
            ☐ 应用双指针和滑动窗口等算法模板解决实际问题。
            ☐ 通过项目实战，将栈、队列、树和链表知识融会贯通。
        第二阶段项目:
            ☐ LRU 缓存模拟器 (哈希表 (O(1) 查找) + 双向链表 (O(1) 移动/删除)。)
            ☐ 命令行路径解析器 (栈 (路径的入栈/出栈/回退)。)
            ☐ 通用表达式求值器 (栈 (双栈法实现中缀表达式的完整计算，包括优先级和括号)。)
            ☐ 社交网络最短路径 (图的 BFS (查找两个用户之间的最短连接路径)。)
        第一阶段验收:
            ☐ 表达式求值器 (支持优先级)
            ☐ "最近访问" 有序列表
            ☐ 二叉树序列化与反序列化
    💻编码实现任务 (Coding Implementation Tasks):
        第一阶段的小玩意:
            ☐ 表达式求值器 (支持优先级),栈 (两个)：一个用于操作数，一个用于运算符。能够计算包含 +, -, *, /, () 的中缀表达式。
            ☐ "最近访问" 有序列表,排序 (自定义) + 链表 (自定义)。实现一个列表，新访问的元素自动移动到列表头部，并限制容量。
            ☐ 二叉树序列化与反序列化,树的遍历 (BFS/DFS) + 队列/数组。将一棵二叉树结构转化为一个紧凑的字符串，并能从字符串恢复原树。
        第二阶段核心任务:
            二叉搜索树 (BST):
                ☐ 实现 insert, search, delete, 并分析它们的最坏 O(N) 和平均 O(logN) 复杂度。
            哈希表（映射/集合）:
                ☐ 实现键值对存储，理解哈希冲突，并解决数组去重/频率统计问题。
            双指针模式:
                ☐ 解决已排序数组的两数之和，及链表的中间节点（快慢指针）。
            滑动窗口模式:
                ☐ 解决求固定长度的最大子数组和，理解窗口的移动和维护。
            非递归遍历:
                ☐ 实现二叉树的中序遍历的非递归版本（使用栈）。
